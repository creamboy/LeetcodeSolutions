213 House Robber II
After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the

Solution
1-d DP: Time ~ O(2N), Space ~ O(N)
Two cases:
If s[0] is robbed, then s[1] and s[N - 1] cannot be robbed, so the max1 = s[0] + max of s[2 .. N - 2];
If s[0] is not robbed, then s[1] and s[N - 1] can be robbed, so the max2 = max of s[1 .. N - 1].
Compare max1 and max2, and take the larger one as the final max.

public class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        // if nums[0] is robbed
        int d1 = nums[0] + dp(nums, 2, n - 2);
        // if nums[0] is not robbed
        int d2 = dp(nums, 1, n - 1);
        return Math.max(d1, d2);
    }

    private int dp(int[] nums, int start, int end) {
        if (start > end)    return 0;
        int[] d = new int[nums.length];
        for (int i = start; i <= end; i++) {
            if      (i == start)        d[i] = nums[i];
            else if (i == start + 1)    d[i] = Math.max(d[i - 1], nums[i]);
            else                        d[i] = Math.max(d[i - 1], d[i - 2] + nums[i]);
        }
        return d[end];
    }
}
